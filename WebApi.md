# Web Application Programming Interface (API) for Bungeni #

A web service to enable other applications to interface with Bungeni data and metadata in a formalized way.  The interface describes a collection of services (resources and corresponding methods) that are accessible over a network.

Applications that can interface with the API:

  * Third party applications that are customized and provided with Bungeni e.g the Plone CMS
  * Client third party applications - A client implementing Bungeni may want to integrate its own applications with Bungeni.
  * Bungeni itself – New views could be developed based on the API services.

The API will provide a unifying interaction model so that such application integration can be done with a common approach and using a common infrastructure. This will reduce tight coupling of Bungeni to other applications. The API will facilitate the ability of external applications to perform these actions by exposing objects as resources as well as methods to add, retrieve and update object attributes.

## Conceptual Requirements ##

The API will expose a set of services (resources and their representations as well as the methods available on each resource). Resources may map to objects or object collections in the Bungeni system. Internal implementation details of the Bungeni application should not leak into the API so as to decouple as much as possible the resource representations from the Bungeni application.

## Design constraints ##
This will be a RESTful api accessible via the HTTP protocol

### Resources ###
A resource maps directly to an object. Resources can be grouped into collections. Each collection will be homogeneous.Collections can exist globally, at the top level of the API; they can also be contained inside a single resource in which case they are sub-collections.

### Resource Data ###
Each call to the API will result in a response containing data (application) and metdata (information that is specific to the RESTful API e.g URLs and relationships). The data response format should standardize to json. This does not constrain from the service providing more data formats. Standard HTTP response codes must also be used with each response.

#### Resource Representation - JSON ####
  * Data associated with a resource is modeled as key:value pairs on the JSON object;
  * The values of key:value pairs use any of the JSON data types of string, number, true, false, null, or arrays. Values can also be objects, in which case this is modeling nested resources;
  * Collections are modeled as an array of objects;
  * The type of resource will be stored under the key:value pair “_type”.
```

{
  "_type": "user",
  "first_name": "member",
  "last_name": "P1_01",
  "middle_name": "nancy"  
}

```_

### Inputs and Outputs ###
The API will allow reading and posting of data. This will be determined on a case-by-case review of each service developed for the API. Explicit input/output limitations should be imposed - messages going in or out of the API should be explicitly capped.

### Entry point ###
There should be one entry point to the API and information contained here would include:
  * listing of top level collections and resources;
  * version information.

### Methods ###
Methods will be executed on resources via their URL. The standard RESTful methods should be used to execeute operations on resources where such operations are implemented. Methods suggested to use are as follows:
  * view;
  * add;
  * edit;
  * list;
  * transition.

### Url Structure ###
Each resource and collection should have a unique url. Links will be generated by the API. A convention to adopt would be to use collection/resource path segments relative to the API entry point together with the relevant method names. Resources should be accessed via their object id.

e.g.
  * /api/ - the entry point to the api;
  * /api/user/list -  collection of users;
  * /api/user/id/view -  the resource “id” inside collection “user”.

### Filters ###
Collections and sub-collections may be filtered using the filter parameter to return only entries that match particular conditions which will be specified by using filter operators in the request URI. The filter syntax is as follows:
`filter=[attribute, operator, value]`

  * attribute- The name of the attribute to filter against;
  * operator - Various operators can be used to specify the conditions for the results:
    * equal;
    * not\_equal;
    * less\_than;
    * less\_than\_or\_equal;
    * greater\_than;
    * greater\_than\_or\_equal;
    * in;
    * not\_in.
  * value - The value to use for the filter.

e.g:
  * /api/user/list?filter=[first\_name,eq,"clerk"] - returns the user(s) whose first name is "clerk".

Multiple filters in a single query are ANDed:

  * /api/user/list?filter=[first\_name,eq,clerk"],[last\_name,eq,"P1\_01"] - returns the user(s) whose first name is "clerk" and last name is "P1\_01".

Multiple querys will be ORed:
  * /api/user/list?filter=[first\_name,eq,clerk"],[gender,eq,female]&filter=[last\_name,eq,"P1\_01"] returns the user(s) whose first name is "clerk" and whose gender is female  as well as the user(s) whose last name is "P1\_01".


### Ordering ###
Specify ordering of query results using the order\_by parameter:

Order by first\_name:
  * /api/user/list?filter=[first\_name,eq,clerk"],[last\_name,eq,"P1\_01"]&order\_by=first\_name

Order by first name and then by last name:
  * /api/user/list?filter=[first\_name,eq,clerk"],[last\_name,eq,"P1\_01"]&order\_by=[first\_name,last\_name]


### Pagination ###
The client should be able to retrieve a subset of the available resources. Pagination separates the collection into smaller collections called pages. The "items\_per\_page" parameter and "start\_index" parameters can be used to specify how many results you want, and where to start from.

  * /api/user/list?start\_index=5;items\_per\_page=40

For paginated collections the response will contain the following additional parameters:

  * start\_index — The index of the first result returned in the response;
  * end\_index  — The index of the last result returned in the response;
  * items\_per\_page — The number of results returned per page in the response;
  * count — The total number of items that would be returned if there were no pagination parameters specified.

### Relationships/Links ###

Resources have relationships to other resources. These relationships can be expressed by hyperlinks on the representation of a resource. Any “href” attribute on an object will be interpreted as a hyperlink. The value of the href attribute should contain an absolute URL that can be retrieved with GET.

### Service Contract ###
This will document with examples the different services provided by the API and how to access them. This will include:
  * The different services and their names;
  * How each service is invoked;
  * The signature for each method in a service;
  * Description of the parameters in a method.

### Versioning and Deprecation ###

The API may change as new features and services are added to Bungeni. To prevent breakages occurring for clients already using the API and to cater for the addition of new features the API needs to be versioned.

A deprecation mechanism will be necessary to act as guide for migrating between different versions.


### Authentication ###
Access to the API may need to be controlled, only authenticated users should be able to request certain services. A validation mechanism will need to implemented.


### Documentation ###
Should cover the following:
  * Definition of all resources, methods and their parameters
  * Sample request/response data formats for each action in the service
  * Documentation of error scenarios along with Server side status codes

## Use Cases for the API ##

#### User Management ####
Object type: User

Operations required/possible:

  * add user;
  * view user - returns a single user
  * list users - returns all users ;
  * edit user - Updates one or more of a user's attributes e.g can be used to reset a user's password;
  * transition user - This can be used to deactivate and reactivate a user;
  * list user group memberships;
  * list user addresses;
  * list user delegations.

A Bungeni user object has several attributes:
At a minimum the user object should have the following attributes:

  * salutation;
  * first\_name;
  * last\_name;
  * email;
  * login;
  * password;
  * gender;
  * date\_of\_birth;
  * birth\_country;
  * birth\_nationality;
  * current\_nationality
  * language.

The user also has a unique ID.

## User Profile ##
The user profile ([issue 690](https://code.google.com/p/bungeni-portal/issues/detail?id=690)) consists of a user's identification attributes (name, login) and any additional attributes stored about the user.
The user is able to modify some aspects of his/her user profile. e.g. current\_nationality, password, description, image etc.
A user's group membership and addresses may be considered part of the user profile.
In this case to update a user profile the following operations may be used:
  * edit user;
To view the user profile the following operations may be used:
  * view user;
  * list user group memberships;
  * list user addresses;
  * list user delegations.
