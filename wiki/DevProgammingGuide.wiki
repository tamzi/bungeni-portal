#summary Bungeni Programming Guide
#labels Phase-Implementation
#sidebar TableOfContents

= Bungeni Programming Guide =

Rules, conventions, guidelines for programming bungeni, to increase consistency, efficiency and maintainability of the bungeni code base. 

These rules are primarily concerned about design, architecture, adoption of selected "best practices". Souce code style guidelines are addressed in a separate document [DevCodeStyleGuide Bungeni Source Code Style Guide].

----

== Misc ==

 * The bungeni python package is not a namespace package.


----
== Security ==

How roles and permissions should be defined and assigned: 
a "programming security policy" that should be considered as an integral part of 
the system design, and must be considered for, and may affect, any other ongoing 
design choices to be made as the system evolves. 

=== General ===

 * Bungeni categorically grants/denies permissions only to *roles* i.e. never directly to a principal (or group). And, to reduce runtime overhead, the `BungeniSecurityPolicy` actually does not perform the check for any direct permission grants on principals and groups.


=== Security definitions (roles, permissions, grants) ===

These are made in several places, namely: 

{{{
bungeni.main/bungeni/security.zcml
bungeni.main/bungeni/models/roles.zcml
bungeni.main/bungeni/models/permissions.zcml	
bungeni.main/bungeni/core/workflows/permissions.zcml (automatically generated via bungeni_custom/workflows/...)

bungeni_custom/workflows/...

bungeni_custom/sys/acl/permissions.zcml
bungeni_custom/sys/acl/roles.zcml
bungeni_custom/sys/acl/meta/...
bungeni_custom/sys/acl/content/...
}}}

 * A premise of Zope 3 security is that all access to an object is denied unless a permission is first granted. Bungeni should adopt a similar approach i.e. should not favour global grants to then deny as needed downstream, but, whenever possible, to prefer the general practice of simply granting only when and as needed.
 * For simplicity, all `bungeni.TYPE.View` permissions should always be redefined to `zope.View`, and this used generically thoughout.



!+type-dependent permissions should be defined/granted along with type definitions themselves

!+most of `sys/acl/...` should not be there; question.zcml is already "orphan code"; why both `/meta` and `/content` sub-folders?


Where, what, and how to define roles/permssions/grants should be clarified...
Some reflection as to support for:

 # user-owned types (always workflowed), with dedicated permissions for various actions (each action possibly being dependent on a feature being enabled or not)
 # system-owned types (may or may not be workflowed) with dedicated permissions, that are exposed "within limits" to some user customization
 # or, system-owned types that are NOT at all exposed to user customization (completely internal to bungeni)
 # support for user-defined roles, and for assigning permissions to them...
 # UI views (typically require globally granted permissions) should use dedicated permissions, and so different than any related model-bound permissions.

=== Distinct permission _scopes_ ===

For clarity of intention, permission _scopes_ should be kept as distinct as possible. Notably, the "permission scope spaces" implied by `bungeni.Authenticated` and those implied by other "custom" roles (all of which imply `bungeni.Authenticated`) overlap. Grants to roles from these two sets should not be mixed, as:

 * Debugging permission checking is made unnecessarily more difficult; indeed undestanding what a permission setting should be by reading the code becomes virtually impossible.
 * It just invites for developer inconsistency.
 * This inconsistency will result in incorrect decisions in some cases e.g. View on a change record of an attachment to a a document may be granted to a member virtue of Authenticated having zope.View (be it globally or locally on the attachment instance or on any other ancestor instance).

I propose adoption of the following policy to keep permission determination as simple as possible, to never mix applying permissions in this way (where what is to be not mixed would be similar, if more stringent, to what has been implemented for workflow permission assignments, from r8919 on):

    For a given specific permission, the "scope" for that permission is either limited to 
    `bungeni.Authenticated` OR ONLY to the set of other custom roles.
    I.e. if we consider two mutually exclusive sets of roles:
    {{{
    A: bungeni.Authenticated
    B: bungeni.Clerk bungeni.Speaker bungeni.Owner bungeni.Signatory bungeni.MP bungeni.Minister
    }}}
    then the "permission space" we can "assign" in would be:
    {{{
    {(permission, object), role, setting)}
    }}}
    where, for any (permission, object) pair, assignments (irrepective of setting) of the permission 
    may only be to roles *only* within _either_ A _or_ B *anywhere* in the application.
    Further, if a permission is assigned globally (here, object=None would mean global) 
    then it _should_ not ever be assigned locally.
    
    I.e. assignments of a given permission must *always be to only one* of 
    the following 4 combinations: `{global, local} x {A, B}`


=== Security requirement statements ===

These are done in:

{{{
bungeni.main/bungeni/models/domain.zcml
bungeni.main/bungeni/ui/configure.zcml
...
}}}

!+identify a simple practice for this

----
== Templates ==

 * Templates should be as dumb as possible, concerning themselves with purely presentational logic; templates should need to have *no* "business" knowledge of data received for rendering.
 
 * Localization of any data is done *outside* of templates. This to make it clear where data *should* be localized, avoiding the frequent occurrences of data either _not being localized_ at all or data _being localized twice_ (in application python code and in the templates). And, as localization cannot be guaranteed to *always* be performed within the templates, then it should *always* be done in application code, outside of the templates.

== i18n ==

Localization of data should be done as late as possible. This is for two reasons:
 # retain the data in its most semantic state as long as possible, to never lose for example teh option to do proper numeric or date artithmentic, or proper string interpolation.
 # to ensure that the internalization takes into proper account the user's locale!
 
Coding implications for this are that values MUST never be i18n'ed at *code load time* (when the containing module is loaded and so executed), but later when the instance/class/construct is created specifically for a given user request. Preferably, all i18n'ing of data is done just prior to rendering a template. 

For example, taking a look at `ui/reports.py`, the first piece of 
non-import code one sees is:

{{{
class TIME_SPAN:
    daily = _(u"Daily")
    weekly = _(u"Weekly")
}}}

This code is executed when bungeni is launched, and the class gets defined with 
the attributes having i18n'ed values (without as yet knowing who the final user 
and locale will be)! If, downstream, this class is used to generate user data, it 
is likley that these translated values are re-translated... all such occurances 
must be avoided (and current ones cleaned out).

<wiki:comment>
!+ ZCML usage
</wiki:comment>

