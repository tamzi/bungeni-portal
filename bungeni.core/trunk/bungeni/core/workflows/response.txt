Response workflow
=================
Note that the response workflow triggers question workflow actions.
If the question workflow does not pass the tests there is no use testing
the response workflow.


  >>> from bungeni.models.domain import Response

Setup
-----

  >>> import bungeni.core.workflows.response
  >>> import bungeni.models.interfaces
  >>> import bungeni.core.interfaces  
  >>> import ore.workflow
  >>> import copy
  
  >>> component.provideAdapter(
  ...    bungeni.core.workflows.WorkflowState,
  ...    (bungeni.models.interfaces.IBungeniContent,))

  >>> component.provideAdapter(
  ...    bungeni.core.workflows.response.WorkflowAdapter,
  ...    (Response,))

  >>> component.provideAdapter(
  ...    ore.workflow.workflow.WorkflowInfo,
  ...    (Response,))

  >>> component.provideHandler(
  ...    bungeni.core.workflows.events.workflowTransitionEventDispatcher)

  >>> import bungeni.core.version
  >>> component.provideAdapter(
  ...    bungeni.core.version.ContextVersioned,
  ...    (bungeni.core.interfaces.IVersionable,),
  ...    bungeni.core.interfaces.IVersioned)

Security Adapters

  >>> import alchemist.security.permission
  >>> import alchemist.security.role

  
  >>> component.provideAdapter(
  ...    alchemist.security.role.GlobalPrincipalRoleMap,
  ...    (bungeni.models.interfaces.IBungeniContent,))

  >>> component.provideAdapter(
  ...    alchemist.security.permission.GlobalRolePermissionMap,
  ...    (bungeni.models.interfaces.IBungeniContent,))

  >>> component.provideAdapter(
  ...    alchemist.security.role.LocalPrincipalRoleMap,
  ...    (bungeni.models.interfaces.IBungeniContent,))

  >>> component.provideAdapter(
  ...    alchemist.security.permission.LocalRolePermissionMap,
  ...    (bungeni.models.interfaces.IBungeniContent,))


  
question setup

  >>> from bungeni.models.domain import Question
  >>> import bungeni.core.workflows.question
  
  >>> component.provideAdapter(
  ...    bungeni.core.workflows.WorkflowState,
  ...    (bungeni.models.interfaces.IBungeniContent,))

  >>> component.provideAdapter(
  ...    bungeni.core.workflows.question.WorkflowAdapter,
  ...    (Question,))

  >>> component.provideAdapter(
  ...    ore.workflow.workflow.WorkflowInfo,
  ...    (Question,))

  >>> component.provideHandler(
  ...    bungeni.core.workflows.events.workflowTransitionEventDispatcher)
  


  
some setup for tests

   >>> from zope import component
   >>> from sqlalchemy import create_engine
   >>> from ore.alchemist.interfaces import IDatabaseEngine
   >>> from ore.alchemist import Session
   >>> from bungeni import models as model
   >>> from bungeni.models import domain, schema
   >>> from bungeni.core.workflows import dbutils

   
   
Setting up Database Connection and Utilities:

   >>> db = create_engine(u'postgres://localhost/bungeni-test', echo=False)
   >>> component.provideUtility( db, IDatabaseEngine, 'bungeni-db' )
   >>> model.metadata.bind = db   
   >>> model.metadata.create_all()    
   >>> from alchemist.security.schema import metadata  
   >>> metadata.bind = db
   >>> metadata.create_all()  
   >>> session = Session()   

     
Transition events
-----------------

We set up event subscribers to make sure all registered transition
events are called.

  >>> from bungeni.core.workflows import testing
  >>> check_transition_events = testing.provide_transition_events_check(
  ...     bungeni.core.workflows.response.wf)
  
Workflow
--------

  >>> from ore.workflow.interfaces import IWorkflow , IWorkflowInfo
  >>> #from bungeni.core.interfaces import IStateWorkflowInfo

  >>> def transitions(response):
  ...     wf = IWorkflow(response)
  ...     info = IWorkflowInfo(response)
  ...     state = info.state().getState()
  ...     return tuple(transition.transition_id for transition in wf.getTransitions(state))


Permissions
-----------
  >>> def permission(response):
  ...   wf = IWorkflow(response)
  ...   info = IWorkflowInfo(response)
  ...   state = info.state().getState()
  ...   return tuple(transition.permission for transition in wf.getTransitions(state))




Questions
we need to have a question in this state (pending response) so that the actions that
gets fired by the response transitions succeed.

  >>> question = domain.Question()
  >>> question.status = u"questionstates.response_pending"
  >>> session.save(question)
  >>> session.flush()
  
  >>> question.question_id
  1L
  
Responses

  >>> response = domain.Response()
  >>> response.response_id = question.question_id
  >>> session.save(response)
  >>> session.flush()
 
  >>> question.question_id
  1L
  
  >>> response.response_id
  1L
  


First we initialize the workflow.
  
  >>> transitions(response)
  (u'create',)

  >>> permission(response)
  (Global(CheckerPublic,zope.security.checker),)

  >>> IWorkflowInfo(response).fireTransition(u'create')

  >>> session.flush()

The response is now in a draft state.


  >>> transitions(response)
   (u'submit',)
    
submit the response to the clerks office:
    
  >>> permission(response)
  (u'bungeni.response.Submit',)

  >>> session.flush()

  
The ministry sends the answer to the clerks office

  >>> IWorkflowInfo(response).fireTransition(u'submit')
  
  >>> transitions(response)
   (u'complete',)

  >>> session.flush()

submitting the response triggers a workflow transition of the question

  >>> transitions(question)
  (u'answer',)

The response is reviewed by the clerk and published

  >>> IWorkflowInfo(response).fireTransition(u'complete')
  
  >>> transitions(response)
  ()

reviewing the response triggers a workflow transition of the question

  >>> transitions(question)
  ()

Transition events check
-----------------------

  >>> print check_transition_events
    {(u'responsestates.draft', u'responsestates.submitted'): True,
     (u'responsestates.submitted', u'responsestates.complete'): True,
     (u'questionstates.responded', u'questionstates.answered'): True}

cleanup
-------
  >>> session.flush()
  >>> session.commit()
  >>> session.close()
